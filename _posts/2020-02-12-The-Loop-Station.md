---
layout: post
title: "[ pd Loop Station ]"
date: 2020-02-13 20:00:00 +0200
categories: Audio-Programming
author: Rayam Luna
image: /assets/img/rayam/2020_02_11_rayaml_blog-cover-small.jpg
excerpt: "This is an attempt to create a Loop Station with features that I wish I had in such a pedal / software."
Keywords: Audio Programming, Pure Data, MCT4048, Loop, Playback, Record
--- 

## [ Overview ]

When you switch from being the user of a product, to become the one who is building the product that you need yourself, things change completely. This is an attempt to create a Loop Station with features that I wish I had in such a pedal / software.

With four independent channels routed to integrated FX busses, such as pitch_shift and reverb, this Loop Station promisses to attend a lot of needs of artists that use loopers to jam in live performances or as tool in the creative process of composing.

<p align="center">
  <iframe
     frameborder="0"
     width="840"
     height="480"
     src="https://drive.google.com/file/d/1uA2-cSqUJZKz0q6C7xz_v4XxDX117IXC/preview">
  </iframe>
</p>

## [ Features~ ]

The Loop Station is designer to be used for live performances, but also, as a tool that can be powerful to help with the creative process composing and arranging songs. So, in addition to the usual features mentioned above, I decided to risk my sleeping time to implement a drum beat trigger based on the sounds generated by the users using any surface, from the mouth like a beatbox or using one's own body as a percurssive surface.

* Inputs: Line In / Microphone / Midi
* 4 tracks (independent)
* Unlimited overdub cycles for each track
* Record / Save each track in unique files
* Record / Save Master Mix
* 2 Fx BUS: Octave / Reverb (Pre Loop | Post Loop)
* Built-in Drum Machine with 2 modes (Body Drum | Pad Beat)

When implementing the features mentioned above, I started by the most important rst: the loop record and playback functions. To create the overdub, a **bang** feeds a counter which goes through selections and bang triggers that pass the signal in the right order to calculate the time/size of each sample, record, stop recording and play it in a loop. This way is possible to start a recording tapping one key once, and if you tap again it stops interrupts the audio input that is sending to [tabwrite~ ]. Then the [timer ] is activated, so we can extract the exact duration of the sample recorded and send it to the array receiving the loops. A [line~ 10] was used to open/interrupt the signal without pops and clicks on the sound output.

<p align="center">
  <iframe
     frameborder="0"
     width="840"
     height="480"
     src="https://drive.google.com/file/d/12yCnNmtEd-CfSkXJF13r0ifS6X5tJXS0/preview">
  </iframe>
</p>

## [ Drum Machine ]

Play drums using your body or any other surface as the beat generator! When implementing the Drum Machine, my intention was to provide a creative way to generate beats in a Live Loop Performance, creating an expressive and spontaneous experience within the process of composing and improvising layers in a song. To make it happen, Pure Data has to detect an acoustic audio input distinguish it by frequency region and attack, and by these features, bang the assigned beat samples for each type of audio received.

When designing this function, I did several tests using the objects **[bonk~ ]** and **[fiddle~ ]**, to see which one would be more accurate detecting and reading the audio input features and unpacking it into distinct data. This process is very useful to trigger sounds based on specific aspects of the acoustic sound produced. After testing different sound sources and initial arguments for each one of the objects mentioned, **[fiddle~ ]** proved to be more accurate to the task. It detects attacks and the amplitudes very well, and send the domain frequency and its partials unpacked in numbers. Which is very useful to trigger different beat samples based on the frequency range and attack of the specic sounds produced by hi-hat, snare, and bass drum. 

It works cool, but it is still very unstable and needs a silent and controlled environment to avoid random frequency and attack detection. I am still developing this function, refining the arguments, specially the amplitude and attack, to filter the audio information in a way that makes it more controllable. "Audio is wild", as mentioned during the course. To get around this issue, while I am developing this function, I provided two modes for the Drum Machine function, one is the described above Body Drum, and the other is the Beat Pad, in which I assigned the beat samples to dierent midi notes, in a more common, but stable approach.

## [ Conclusion (

The process of designing such functionalities opened my mind to a huge amount of new information regarding audio programming signal flow, digital audio processing and eectively made me understand many of the issues and limitations encountered within my experience using equipment, hardware, and software when performing or producing music. To design a Loop Station with all the desired functionalities, is still a challenge, especially when it comes to playback latency and delay, tempo accuracy, time manipulation, artifacts, and synchronization. All in all, it is a valuable way to learn audio programming.

Tusen takk!

## [ Prototype working: (Demo)nstration ]

<p align="center">
<iframe width="832" height="468" src="https://www.youtube.com/embed/95EbyaaJifg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
</iframe>
</p>